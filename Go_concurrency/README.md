# final-exam

(1) What argument can you give that there will be no dealock among these processes?

Deadlock is when two or more processes got blocked because each of them are waiting for the other to releasse a resource that they need. In this context of producers generating numbers and consumers receiving numbers, the deadlock situation would not occur. 

The producer processes 'producer_one' and 'producer_two' does not have deadlock because each one is generating numbers and saving it to the 'inCh' channel. Producer one don't need any resources from producer two, and vice versa. They might be blocked if no cutomer is consuming the number from 'inCh' channle and the buffered 'inCh' is full. But it is not the case here. 

The consumer processes 'consumer_one' and 'consumer_two' also does not result in deadlock situation. Because each consumer gets a number from the 'inCh' in random interval. It is not the case that the two consumer would get a number from each other. 

The processes between producer and consumer also does not cause any deadlock. Because the producers does not need any resources from the consumer, and consumers get numbers from the channels.

Lastly, the filter_number process gets number from the 'outCh'. The process is basically isolated from consumer and producer processes by using the buffered channel as intermediary to prevent deadlocks. 

In summary, the buffered channel helps avoid deadlocks between processes.





(2) We get "easy" fan-out and fan-in here with Go channels, because a channel is a data structure that is not bound to any single process. How would we handle this situation in Elixir, where the mailbox semantics in actors mean that our "channel" is always attached to a single process? How do we have 2 producers creating and distributing values to 2 consumers?


In Elixir, the "channel" being attached to a single process is the message in the process. Elixir use pattern matching to send messages between processes. 

For producer one, it will have a message such as "{:generateNum}" when the process is spawned and linked in new. Within the message block, it will begin a for loop to send consumer one and consumer two odd numbers. A random sleep time will be implemented between each send. Similarly for producer two with even integers. 

For consumer one, it will take in a number in the process parameter such as "def consumer_one(num)". There will be two messages, one to match the odd number generated by producer one such as "{:doubleNum, odd}", and another to match the even number generated by producer two such as "{:doubleNum, even}". Then the consumer send the squared_num to filter processs. The same for consumer two.

By having pattern matching to handle messages and each producer alternate between the two consumers to send number to, this avoids deadlock situations where consumers want to get number from each other.
